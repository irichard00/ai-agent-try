# PlanningAgent.java 代码说明文档

## 文件概述

**文件路径**: `/home/rich/dev/study/ai-agent-try/genie-backend/src/main/java/com/jd/genie/agent/agent/PlanningAgent.java`

**主要功能**: 规划代理，继承自 ReActAgent，专门负责创建和管理任务计划，将复杂任务分解为可执行的步骤序列。

**继承关系**: PlanningAgent -> ReActAgent -> BaseAgent

**设计模式**: 
- ReAct (Reasoning + Acting) 模式
- 责任链模式 (计划步骤管理)
- 状态机模式 (计划状态管理)

## 类结构分析

### 类定义
```java
@Slf4j
@Data
@EqualsAndHashCode(callSuper = true)
public class PlanningAgent extends ReActAgent
```

### 核心属性

#### 计划管理相关
- **toolCalls** (List<ToolCall>): 待执行的工具调用列表
- **maxObserve** (Integer): 输出最大观察长度限制
- **planningTool** (PlanningTool): 计划管理工具实例
- **planId** (String): 计划唯一标识符

#### 配置控制
- **isColseUpdate** (Boolean): 是否关闭动态更新计划功能

#### 提示词管理  
- **systemPromptSnapshot** (String): 系统提示词快照
- **nextStepPromptSnapshot** (String): 下一步提示词快照

## 构造方法详细说明

### PlanningAgent 构造方法

**方法签名**: 
```java
public PlanningAgent(AgentContext context)
```

**方法用途**: 
初始化规划代理，配置计划相关的提示词、工具和模型参数

**参数说明**:
- `context` (AgentContext): 代理执行上下文

**初始化流程**:

1. **基础信息设置**:
   - 设置代理名称为 "planning"
   - 设置描述为计划创建和管理代理

2. **工具信息构建**:
   - 遍历上下文工具集合
   - 构建工具提示词格式: "工具名：[name] 工具描述：[description]"

3. **提示词配置**:
   - 获取规划器系统提示词模板
   - 替换占位符: {{tools}}, {{query}}, {{date}}, {{sopPrompt}}
   - 配置下一步执行提示词
   - 保存提示词快照用于文件信息动态更新

4. **模型和参数设置**:
   - 设置打印器和最大执行步数
   - 初始化规划器专用 LLM 模型
   - 配置计划更新控制开关

5. **工具集合初始化**:
   - 将 PlanningTool 添加到可用工具中
   - 设置计划工具的代理上下文

## 核心方法详细说明

### think 方法

**方法签名**: 
```java
@Override
public boolean think()
```

**方法用途**: 
规划代理的思考阶段，分析当前情况并决定是否需要创建或更新计划

**返回值**: 
- boolean: 是否需要执行行动阶段

**执行流程**:

1. **文件信息处理**:
   - 获取产品文件信息 (不包含详细内容)
   - 动态更新系统和下一步提示词中的文件占位符

2. **计划更新控制检查**:
   - 如果关闭了动态更新且已存在计划
   - 直接调用 `stepPlan()` 推进计划进度
   - 返回 true 继续执行

3. **用户消息准备**:
   - 检查最后一条消息角色
   - 如果不是用户消息，添加下一步提示词作为用户消息

4. **LLM 计划调用**:
   - 设置流消息类型为 "plan_thought"
   - 调用 LLM 的 `askTool` 方法生成计划
   - 传入完整的消息历史和系统提示词
   - 支持流式输出 (根据配置)

5. **响应处理**:
   - 提取工具调用列表
   - 非流式模式下发送计划思考内容
   - 记录详细的响应日志

6. **记忆更新**:
   - 根据函数调用类型选择消息格式
   - 将助手响应添加到记忆中

**异常处理**:
- 捕获所有异常并记录错误日志
- 不中断执行流程，返回 true 继续

### act 方法

**方法签名**: 
```java
@Override
public String act()
```

**方法用途**: 
执行阶段实现，处理计划工具调用或推进计划执行

**返回值**: 
- String: 下一个待执行的任务或执行结果

**执行流程**:

1. **计划更新控制检查**:
   - 如果关闭动态更新且已有计划
   - 直接调用 `getNextTask()` 获取下一个任务

2. **工具调用执行**:
   - 遍历所有工具调用命令
   - 执行每个工具并收集结果
   - 应用最大观察长度限制

3. **记忆更新策略**:
   - **结构化解析模式**: 将结果追加到最后消息
   - **函数调用模式**: 创建独立工具消息

4. **计划处理**:
   - 如果存在有效计划
   - 根据更新控制设置推进计划
   - 调用 `getNextTask()` 获取下一步任务

5. **结果返回**:
   - 有下一任务时返回任务内容
   - 否则返回工具执行结果组合

### getNextTask 方法

**方法签名**: 
```java
private String getNextTask()
```

**方法用途**: 
获取计划中的下一个待执行任务

**返回值**: 
- String: 下一个任务描述或 "finish"

**执行逻辑**:

1. **完成状态检查**:
   - 遍历所有计划步骤状态
   - 检查是否全部标记为 "completed"
   - 如果全部完成，设置代理状态为 FINISHED

2. **当前步骤获取**:
   - 获取计划的当前步骤内容
   - 如果存在当前步骤，解析步骤内容
   - 处理多步骤情况 (使用 "<sep>" 分隔符)

3. **输出处理**:
   - 发送完整计划到打印器
   - 为每个步骤发送单独的任务消息
   - 返回当前步骤内容

**计划状态管理**:
- 全部完成: 返回 "finish"
- 有当前步骤: 返回步骤内容
- 无步骤: 返回空字符串

### run 方法

**方法签名**: 
```java
@Override
public String run(String request)
```

**方法用途**: 
规划代理的主运行方法，在执行前添加计划前置提示词

**参数说明**:
- `request` (String): 原始请求内容

**返回值**: 
- String: 执行结果

**执行流程**:
1. **计划存在性检查**: 如果尚无计划，添加计划前置提示词
2. **请求预处理**: 将前置提示词与原始请求合并  
3. **调用父类运行**: 执行完整的 ReAct 循环

## 计划管理机制

### 计划创建流程
1. **任务分析**: 分析复杂任务的构成
2. **步骤分解**: 将任务分解为可执行的步骤
3. **依赖识别**: 识别步骤间的依赖关系
4. **优先级排序**: 确定步骤执行顺序

### 计划执行控制
- **动态更新模式**: 根据执行结果动态调整计划
- **静态执行模式**: 按照初始计划严格执行
- **状态跟踪**: 实时跟踪每个步骤的执行状态

## 工具集成

### PlanningTool 集成
- 专门的计划管理工具
- 支持计划创建、更新、状态管理
- 与代理上下文紧密集成

### 计划持久化
- 计划状态在代理生命周期内保持
- 支持计划的序列化和反序列化
- 提供计划恢复机制

## 配置选项

### 计划更新控制
- `isColseUpdate=true`: 静态计划执行
- `isColseUpdate=false`: 动态计划调整

### 提示词配置
- 规划器专用系统提示词
- 支持多种占位符替换
- 动态文件信息注入

## 异常处理

### 思考阶段异常
- 记录错误日志但不中断执行
- 确保计划流程的连续性

### 执行阶段异常
- 工具执行异常独立处理
- 计划状态保持一致性

## 使用场景

PlanningAgent 适用于:
1. **复杂任务分解**: 将大型任务分解为子任务
2. **项目管理**: 创建和管理项目执行计划
3. **工作流设计**: 设计多步骤的工作流程
4. **依赖管理**: 处理有依赖关系的任务序列
5. **进度跟踪**: 跟踪任务执行进度和状态

该代理是多代理系统中的重要组件，负责任务的高级规划和协调。